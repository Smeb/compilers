import java_cup.runtime.*;
import java.util.ArrayList;

parser code {:

  public Boolean syntaxErrors = false;

  public void syntax_error(Symbol current_token){
  report_error("Syntax error at line " + (current_token.left+1) +
  ", column " + current_token.right + "\n", null);
  }
  private Lexer lexer;

  public Parser(Lexer lex) {
    super(lex);
    lexer = lex;
  }

:}

terminal BADCHAR;
/** primitives **/
  /* syntactic smybols */
  terminal LANGLE, RANGLE, LBRACKET, RBRACKET, COMMA, LBRACE, RBRACE,
  COLON, LPAREN, RPAREN, MAIN, SEMICOLON;
  /* items */
  terminal BOOL, CHAR, FLOAT, INTEGER, RATIONAL;
  /* collections */
  terminal STRING_LITERAL;
  /* language types */
  terminal SEQ_T, TOP_T, BOOLEAN_T, CHAR_T, DICT_T, FLOAT_T, INT_T,
  RATIONAL_T, VOID;
/* operators */
  terminal AND, DIV, EQ, IN, LTEQ, MINUS, MULT, NEQ, OR
, PLUS, ASSIGNMENT, POW, DOT, APPEND, NOT, LEN, IDENTIFIER;
/** parsing constructs **/
  /* structural constructs */
  nonterminal program;
  /* declarations */
  nonterminal declarations, main, statements, statement;
  nonterminal var_declaration, function_declaration;
  /* low level constructs */
  nonterminal collection, item, type, type_with_top, dict_t, sequence_t;
  nonterminal expression, l_r_op, evaluable, function_call;
  /* list nonterminals */
  nonterminal sequence_start, sequence_contents, sequence_body,
  dict_start, dict_contents, dict_body, dict_value;

precedence left PLUS, MINUS, OR, APPEND, COMMA, MULT, DIV, AND;
precedence right POW, IN, ASSIGNMENT;
precedence nonassoc NOT, LANGLE, LTEQ, RANGLE, EQ, NEQ;

program ::= main;
main ::= MAIN LBRACE statements RBRACE SEMICOLON;
statements ::= statement statements
            |
            ;

statement ::= expression;

expression ::= item
            | collection
            | evaluable
            ;

item ::= CHAR | FLOAT | INTEGER | RATIONAL | BOOL;
type ::= BOOLEAN_T | CHAR_T | dict_t | FLOAT_T | INT_T | RATIONAL_T | sequence_t;
type_with_top ::= TOP_T | type;
evaluable ::= expression l_r_op expression
            | NOT expression
            | LEN LPAREN expression RPAREN
            | MINUS expression
            | LPAREN expression RPAREN
            | function_call
            ;

function_call ::= IDENTIFIER LPAREN sequence_contents RPAREN;

collection ::= STRING_LITERAL;

sequence_t ::= SEQ_T LANGLE type_with_top RANGLE;
sequence_start ::= LBRACKET sequence_contents RBRACKET;
sequence_contents ::= sequence_body
                |
                ;

sequence_body ::= expression
                | sequence_body COMMA expression
                ;

dict_t ::= DICT_T LANGLE type_with_top COMMA type_with_top RANGLE;
dict_start ::= LBRACE dict_contents RBRACE;
dict_contents ::= dict_body
              |
              ;
dict_body ::= dict_value
          | dict_body COMMA dict_value
          ;
dict_value ::= expression COLON expression;

l_r_op ::= AND | DIV | EQ | IN | LANGLE | LTEQ | MINUS | MULT | NEQ | OR
| PLUS | POW;
