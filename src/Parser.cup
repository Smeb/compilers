import java_cup.runtime.*;
import java.util.ArrayList;

parser code {:

  public Boolean syntaxErrors = false;

  public void syntax_error(Symbol current_token){
  report_error("Syntax error at line " + (current_token.left+1) +
  ", column " + current_token.right + "\n", null);
  }
  private Lexer lexer;

  public Parser(Lexer lex) {
    super(lex);
    lexer = lex;
  }

:}

terminal BADCHAR;
/** primitives **/
  /* syntactic smybols */
  terminal LANGLE, RANGLE, LBRACKET, RBRACKET, COMMA, LBRACE, RBRACE,
  COLON, LPAREN, RPAREN, MAIN, SEMICOLON, FDEF, TDEF, ALIAS, RETURN;
  /* items */
  terminal BOOL, CHAR, FLOAT, INTEGER, RATIONAL;
  /* collections */
  terminal STRING_LITERAL;
  /* language types */
  terminal SEQ_T, TOP_T, BOOLEAN_T, CHAR_T, DICT_T, FLOAT_T, INT_T,
  RATIONAL_T, VOID;
/* operators */
  terminal AND, DIV, EQ, IN, LTEQ, MINUS, MULT, NEQ, OR
, PLUS, ASSIGNMENT, POW, DOT, APPEND, NOT, LEN, IDENTIFIER;
  terminal IF, FI, ELIF, DO, OD, WHILE, FORALL, ELSE, THEN, PRINT,
  READ;
/** parsing constructs **/
  /* structural constructs */
  nonterminal program;
  /* declarations */
  nonterminal declarations, declaration, main, statements, statement,
  assignment, multiple_assignments,
  variable_declarations;
  nonterminal variable_declaration, function_declaration,
  type_declaration, alias_declaration;
  /* low level constructs */
  nonterminal collection, item, type, type_with_top, dict_t, sequence_t,
  ftype;
  nonterminal expression, l_r_op, evaluable, function_call;
  /* list nonterminals */
  nonterminal sequence_start, sequence_contents, sequence_body,
  dict_start, dict_contents, dict_body, dict_value,
  type_id_contents, type_id_body, type_id;
  /* conditional flow nonterminals */
  nonterminal while, for;
  /* io_ops */
  nonterminal io_op, named_ent, dot_access, collection_access,
  possible_collections, return, if_start, if_end, elif, else;

  //working set
  nonterminal initialised;

precedence left PLUS, MINUS, OR, APPEND, COMMA, MULT, DIV, AND;
precedence right POW, IN, ASSIGNMENT;
precedence nonassoc NOT, LANGLE, LTEQ, RANGLE, EQ, NEQ;

start with program;

program ::= declarations main declarations;
main ::= MAIN LBRACE variable_declarations statement SEMICOLON statements RBRACE SEMICOLON;

statements ::= statement SEMICOLON statements
            |
            ;

statement ::= io_op
            | if_start
            | while
            | for
            | return
            | expression
            | named_ent assignment
            ;

declarations ::= declaration SEMICOLON declarations
              |
              ;

declaration ::= function_declaration
              | variable_declaration
              | alias_declaration
              | type_declaration
              ;

function_declaration ::= FDEF ftype IDENTIFIER LPAREN type_id_contents
RPAREN LBRACE variable_declarations statement SEMICOLON statements RBRACE;

variable_declarations ::= variable_declarations variable_declaration SEMICOLON
                      |
                      ;

variable_declaration ::=  type IDENTIFIER initialised;
initialised::= assignment
            |
            ;

assignment ::= ASSIGNMENT expression multiple_assignments;

multiple_assignments ::= COMMA expression multiple_assignments
                      |
                      ;


type_declaration ::= TDEF IDENTIFIER LBRACE type_id_contents RBRACE;
alias_declaration ::= ALIAS type type;


// need to factor in identifier to expression
expression ::= item
            | collection
            | evaluable
            ;

item ::= CHAR | FLOAT | INTEGER | RATIONAL | BOOL;
type ::= IDENTIFIER | BOOLEAN_T | CHAR_T | dict_t | FLOAT_T | INT_T | RATIONAL_T | sequence_t;
ftype ::= VOID | type;
type_with_top ::= TOP_T | type;
evaluable ::= expression l_r_op expression
            | NOT expression
            | LEN LPAREN expression RPAREN
            | MINUS expression
            | LPAREN expression RPAREN
            | function_call
            ;
l_r_op ::= AND | DIV | EQ | IN | LANGLE | LTEQ | MINUS | MULT | NEQ | OR
| PLUS | POW | APPEND;

function_call ::= IDENTIFIER LPAREN sequence_contents RPAREN;

collection ::= STRING_LITERAL
            | dict_start
            | sequence_start
            ;

sequence_t ::= SEQ_T LANGLE type_with_top RANGLE;
sequence_start ::= LBRACKET sequence_contents RBRACKET;
sequence_contents ::= sequence_body
                |
                ;

sequence_body ::= expression
                | sequence_body COMMA expression
                ;

dict_t ::= DICT_T LANGLE type_with_top COMMA type_with_top RANGLE;
dict_start ::= LBRACE dict_contents RBRACE;
dict_contents ::= dict_body
              |
              ;

dot_access ::= expression DOT IDENTIFIER;

dict_body ::= dict_value
          | dict_body COMMA dict_value
          ;
dict_value ::= expression COLON expression;

type_id_contents ::= type_id_body
                  |
                  ;

type_id_body ::= type_id_body COMMA type_id
              | type_id
              ;

type_id ::= type IDENTIFIER;

while ::= WHILE LPAREN expression RPAREN DO statements OD;
for ::= FORALL LPAREN IDENTIFIER IN possible_collections RPAREN DO statements DO
    ;
if_start ::= IF LPAREN expression RPAREN THEN statements if_end;
if_end ::= elif else FI;

elif ::= elif ELIF statements
      |
      ;

else ::= ELSE statements
      |
      ;


// We can have identifier, accessed element, or indexed element as io
// value
named_ent ::= IDENTIFIER
          | dot_access
          | collection_access
          ;

possible_collections ::= named_ent
                     | collection
                     | function_call
                     ;

collection_access ::= possible_collections LBRACKET expression RBRACKET;

return ::= RETURN expression
        | RETURN
        ;

io_op ::= PRINT
      | READ named_ent
      ;
