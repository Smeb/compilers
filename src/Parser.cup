import java_cup.runtime.*;
import java.util.ArrayList;

scan with {: return lexer.next_token(); :};

parser code {:

  public Boolean syntaxErrors = false;

  public void syntax_error(Symbol current_token){
  report_error("Syntax error at line " + (current_token.left+1) +
  ", column " + current_token.right + "\n", null);
  }

  static class Node {
    public ArrayList<Node> children;
    private static int globalCounter = 0;

    public int counter;
    private Object value;

    public Node(Object value){
      Node.globalCounter += 1;
      this.counter = Node.globalCounter;
      this.value = value;
      this.children = new ArrayList<Node>();
    }

    public void addChild(Node n){ children.add(n); }

    public String toString(){
      String ret = "";
      ret += String.format("%d [label=\"%s\"];\n",
                            counter, value.toString());
      for(Node n: children){
        ret += String.format("%d -> %d;\n", this.counter, n.counter);
        ret += n.toString();
      }
      return ret;
    }
  }

  private Lexer lexer;

  public Parser(Lexer lex) {
    super(lex);
    lexer = lex;
  }

:};

// Do something with ILLEGAL_CHARARCTER or drop it.
// define the set of atomic types
terminal INTEGER, IDENTIFIER, SEMICOLON, RATIONAL, CHAR;
// set of operators
terminal PLUS, MINUS, MULT, DIV;

terminal LPAREN, RPAREN, LBRACE, RBRACE, LBRACKET, RBRACKET;
terminal STRING_LITERAL;

terminal FOR, FORALL, THEN, ELSE, FDEF, TDEF, READ, PRINT, FLOAT;
terminal DO, OD, IF, FI, COLON, IN, WHILE, RETURN, POW, ELIF;

// Comparsion operators
terminal LTEQ, GTEQ, NEQ, EQ, LT;

terminal OR, AND, NOT;
terminal APPEND, GT, UNDERSCORE, PERIOD, COMMA, LEN;

terminal BOOLEAN_T, CHAR_T, DICT_, FLOAT_T, INT_T, RATIONAL_T, SEQ_T, TOP_T;
terminal VOID_T, DICT_T, MAIN;
terminal ASSIGNMENT, ALIAS;

terminal T, F;

terminal BADCHAR;

nonterminal  program, main;
nonterminal function_body, function_def, functions, parameter_list;
nonterminal statements, statement;
nonterminal sequence, type;
nonterminal full_exp, simple_exp, operator;

precedence left PLUS, MINUS;
precedence left DIV, MULT;

start with program;

// Worth looking into
program ::= functions main | main functions | main | functions main functions;

main ::= MAIN LBRACE function_body RBRACE;

functions ::=  function_def functions | FDEF;
function_def ::= FDEF type IDENTIFIER LPAREN parameter_list RPAREN function_body LBRACE RBRACE;
function_body ::= statement;
statement ::= SEMICOLON;


sequence ::= SEQ_T LT type GT;
type ::= IDENTIFIER // Identifier since alias can map types to names
      | TOP_T
      | BOOLEAN_T
      | CHAR_T
      | DICT_T
      | FLOAT_T
      | INT_T
      | RATIONAL_T
      | SEQ_T
      | VOID_T;
