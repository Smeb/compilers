import java_cup.runtime.*;
import java.util.ArrayList;

scan with {: return lexer.next_token(); :};

parser code {:

  public Boolean syntaxErrors = false;

  public void syntax_error(Symbol current_token){
  report_error("Syntax error at line " + (current_token.left+1) +
  ", column " + current_token.right + "\n", null);
  }

  static class Node {
    public ArrayList<Node> children;
    private static int globalCounter = 0;

    public int counter;
    private Object value;

    public Node(Object value){
      Node.globalCounter += 1;
      this.counter = Node.globalCounter;
      this.value = value;
      this.children = new ArrayList<Node>();
    }

    public void addChild(Node n){ children.add(n); }

    public String toString(){
      String ret = "";
      ret += String.format("%d [label=\"%s\"];\n",
                            counter, value.toString());
      for(Node n: children){
        ret += String.format("%d -> %d;\n", this.counter, n.counter);
        ret += n.toString();
      }
      return ret;
    }
  }

  private Lexer lexer;

  public Parser(Lexer lex) {
    super(lex);
    lexer = lex;
  }

:};

// define the set of atomic terminal types
terminal BOOLEAN_T, CHAR_T, DICT_, FLOAT_T, INT_T, RATIONAL_T, SEQ_T,
TOP_T, DICT_T;

// set of operators
terminal PLUS, MINUS, MULT, DIV,  POW;

// set of formatted data types
terminal FLOAT, INTEGER, STRING_LITERAL, IDENTIFIER, CHAR, T, F,
RATIONAL;

// bracket symbols
terminal LPAREN, RPAREN, LBRACE, RBRACE, LBRACKET, RBRACKET;

// logical flow keywords
terminal DO, OD, IF, FI, FOR, FORALL, THEN, ELSE, WHILE, ELIF, RETURN;

// language keywords
terminal FDEF, TDEF, READ, PRINT, COLON, IN, SEMICOLON, APPEND, RANGLE,
UNDERSCORE, PERIOD, COMMA, LEN, ASSIGNMENT, ALIAS, VOID;

// Comparsion operators
terminal LTEQ, NEQ, EQ, LANGLE;
// logical comparison operators
terminal OR, AND, NOT;


terminal MAIN;

terminal BADCHAR;

nonterminal program, declarations, declaration, var_declaration,
func_declaration, type_declaration, alias_declaration, expression,
non_primitive, literal, evaluable, l_r_operator, main, statements,
declaration_list_prime, declaration_list, function_call,
statement, mutator, slice_op, index_op, nullable, concat, type_id_pair,
type, type_with_top, dict_t, sequence_t, sequence_definition,
expression_list_prime, expression_list, dict_definition,
dict_list_prime, dict_list, dict_elem, ftype, parameters;

precedence left PLUS, MINUS;
precedence left DIV, MULT;

start with program;

// program main body can come before and after other declarations but
// there can only be one, like in Highlander
program ::= declarations main declarations;

declarations ::= declaration SEMICOL declarations
              |

declaration  ::= var_declaration
              |  func_declaration
              |  type_declaratiion
              |  alias_declaration

var_declaration ::= type_id_pair
                | type expression

func_declaration ::= FDEF functype IDENTIFIER LPAREN parameters RPAREN
LBRACE statements RBRACE;
type_declaration ::= TDEF IDENTIFIER LBRACE declaration_list_prime RBRACE;
alias_declaration ::= ALIAS type IDENTIFIER;

expression ::= literal
            | evaluable
            | function_call
            | non_primitive DOT IDENTIFIER

// intense debugging
non_primitive ::= IDENTIFIER
              | IDENTIFIER index_op
              | sequence_definition index_op
              | dict_definition index_op
              | function_call
              | function_call index_op

literal ::= STRING_LITERAL
          | sequence_definition
          | dict_definition
          | CHAR
          | F
          | FLOAT
          | INTEGER
          | RATIONAL
          | T

evaluable ::= NOT expression
          | expression l_r_operator expression
          | LEN LPAREN expression RPAREN
          | expression IN expression
          | MINUS expression
          | LPAREN expression RPAREN

l_r_operator ::= AND
              | OR
              | PLUS
              | MINUS
              | TIMES
              | DIV
              | POW
              | LANGLE
              | LTEQ
              | EQ
              | NEQ
              | OR

main ::= MAIN LBRACE statements RBRACE SEMICOLON;

statements ::= statement SEMICOLON statements
            |
            ;

parameters ::= type_id_pair
            | declaration_list type_id_pair
            |
            ;

declarataion_list_prime ::= type_id_pair COMMA declaration_list
              type_id_pair
            | type_id_pair;

declaration_list ::= type_id_pair COMMA declaration_list
                  |
                  ;

function_call ::= IDENTIFIER LPAREN expression_list_prime  RPAREN

statement ::=

// TODO: wtf is happening?!
mutator ::= index_op mutator
        | slice_op mutator
        |

slice_op ::= LRACKET nullable COLON nullable RBRACKET
index_op ::= LBRACKET expression mutator RBRACKET

nullable ::= expression mutator
          |

concat ::= expression CONCAT expression
io_operation ::= READ IDENTIFIER
              | PRINT IDENTIFIER
              | PRINT expression
              ;

type_id_pair ::= type IDENTIFIER
// types
type ::= IDENTIFIER // Identifier since alias can map types to names
      | BOOLEAN_T
      | CHAR_T
      | dict_t
      | FLOAT_T
      | INT_T
      | RATIONAL_T
      | sequence_t

type_with_top ::= type
              | TOP_T

dict_t ::= DICT LANGLE type_with_top COMMA type_with_top RANGLE
sequence_t ::= SEQ LANGLE type_with_top RANGLE
sequence_definition ::= LBRACKET expression_list RBRACKET

expression_list_prime ::= expression_list COMMA expression
                 | expression
                 |

expression_list ::= expression
                | expression COMMA expression_list

dict_definition ::= LBRACE dict_list_prime RBRACE

dict_list_prime ::= dict_list COMMA dict_elem
                 | dict_elem
                 |

dict_list ::= dict_elem
            | dict_elem COMMA dict_list

dict_elem ::= expression COLON expression

ftype ::= type
      | VOID
