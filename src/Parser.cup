import java_cup.runtime.*;
import java.util.ArrayList;

parser code {:

  public Boolean syntaxErrors = false;

  public void syntax_error(Symbol current_token){
  report_error("Syntax error at line " + (current_token.left+1) +
  ", column " + current_token.right + "\n", null);
  }
  private Lexer lexer;

  public Parser(Lexer lex) {
    super(lex);
    lexer = lex;
  }

:}

terminal BADCHAR;
/** primitives **/
  /* syntactic smybols */
  terminal LANGLE, RANGLE, LBRACKET, RBRACKET, COMMA, LBRACE, RBRACE,
  COLON;
  /* items */
  terminal BOOL, CHAR, FLOAT, INTEGER, RATIONAL;
  /* collections */
  terminal STRING_LITERAL;
  /* language types */
  terminal SEQ_T, TOP_T, BOOLEAN_T, CHAR_T, DICT_T, FLOAT_T, INT_T,
  RATIONAL_T, VOID;
  /* operators */
  terminal AND, DIV, EQ, IN, LTEQ, MINUS, MULT, NEQ, OR
, PLUS, ASSIGNMENT, POW, DOT, APPEND;
/** parsing constructs **/
  /* structural constructs */
  nonterminal program;
  /* low level constructs */
  nonterminal collection, item, type, type_with_top, dict_t, sequence_t;
  nonterminal expression;
  /* collection implementors */
nonterminal sequence_start, sequence_contents,
sequence_body, dict_start, dict_contents, dict_body,
dict_value;

program ::= sequence_t
          | sequence_start
          | dict_t
          | dict_start
          ;

expression ::= item
            | collection
            ;

item ::= CHAR | FLOAT | INTEGER | RATIONAL | BOOL;
type ::= BOOLEAN_T | CHAR_T | dict_t | FLOAT_T | INT_T | RATIONAL_T | sequence_t;
type_with_top ::= TOP_T | type;


collection ::= STRING_LITERAL;

sequence_t ::= SEQ_T LANGLE type_with_top RANGLE;
sequence_start ::= LBRACKET sequence_contents RBRACKET;
sequence_contents ::= sequence_body
                |
                ;

sequence_body ::= expression
                | sequence_body COMMA expression
                ;

dict_t ::= DICT_T LANGLE type_with_top COMMA type_with_top RANGLE;
dict_start ::= LBRACE dict_contents RBRACE;
dict_contents ::= dict_body
              |
              ;
dict_body ::= dict_value
          | dict_body COMMA dict_value
          ;
dict_value ::= expression COLON expression;

l_r_op ::= AND | DIV | EQ | IN | LANGLE | LTEQ | MINUS | MULT | NEQ | OR
| PLUS | POW;
